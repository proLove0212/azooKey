# Dicdata Format

azooKeyの辞書データは次のようなフォーマットになっています。

NOTE: LOUDSそのものに関する解説は行いません。

## 辞書データ

辞書データは次の4つの種類のファイルからなります。

* `.louds`
* `.loudschars2`
* `.charID`
* `.loudstxt3`

まず、`.louds`のファイルがLOUDS Trieをバイナリ形式で保存したものです。

次に、`.loudschars2`は各ノードに割り当てられた文字を記録するものです。ただしUnicode文字列の代わりに、1バイトのCharacter IDで表現されています。このため、`.loudschars2`は1バイトずつ処理できます。`.charID`がCharacterをIDに割り当てるためのデータを格納します。

最後に、`.loudstxt3`に各ノードに割り当てられたエントリーのデータが記録されています。

azooKeyの辞書ルックアップは次のように進みます。

1. 起動時に一度だけ`charID`が読み込みます。以降はこれを参照してクエリをID列に変換します。
1. クエリを受け取ったら、ID列に変換します。クエリの先頭の文字に対応する`louds`と`loudschars2`を読み込みます。Swift側ではこの2つをセットにして`LOUDS`構造体が作られ、キャッシュされます。
1. `LOUDS`を検索し、必要なノードの番号を列挙します。
1. クエリの先頭の文字に対応する`loudstxt3`を読み込み、必要な番号のノードに記録されたデータを読み出します。読み出したデータを`DicdataElement`形式に変換し、以降の処理で利用します。なお、`loudstxt3`の方はキャッシュしないので、必要になるたびにIOが走ります。

### `.louds`の構造

TBW

### `.loudschars2`の構造

TBW

### `.charID`の構造

TBW

### `.loudstxt3`の構造

TBW

## 重みデータ（CID）

品詞バイグラムの重み行列が疎行列になることから、CIDの重みデータはフォーマットを工夫しています。

TBW

## 重みデータ（MID）

こちらは疎行列ではないため、重み行列をそのままバイナリ化したものが`mm.binary`として保存されています。

TBW
